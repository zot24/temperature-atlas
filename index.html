<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>Global Temperature Atlas</title>
    <!-- MapLibre GL JS (with fallback to cdnjs if unpkg is blocked) -->
    <script src="https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.js"></script>
    <script>
        if (!window.maplibregl) {
            document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/maplibre-gl/4.1.2/maplibre-gl.js"><\/script>');
        }
    </script>
    <link href="https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/maplibre-gl/4.1.2/maplibre-gl.css" rel="stylesheet" />

    <link
        href="https://fonts.googleapis.com/css2?family=Instrument+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);

            --ui-pad: 20px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Instrument Sans', sans-serif;
            background: #0a0e17;
        }

        #map-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
        }

        #map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #temp-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            opacity: var(--heat-opacity, 0.35);
            mix-blend-mode: multiply;
            transition: opacity 120ms ease;
            will-change: transform, opacity;
            transform: translate3d(0px, 0px, 0);
            filter: saturate(var(--heat-saturate, 1)) contrast(var(--heat-contrast, 1));
            transform-origin: 50% 50%;
        }

        /* While panning, we translate the existing heat image with the map for smoothness */
        #temp-canvas.is-moving {
            opacity: var(--heat-opacity-moving, 0.18);
        }

        /* Hide during expensive re-render / zoom animations to avoid visual mismatch */
        #temp-canvas.is-hidden {
            opacity: 0;
        }

        /* Ensure popups appear ABOVE the heat canvas (canvas is z-index: 2) */
        #map .maplibregl-popup {
            z-index: 3;
        }

        /* Popup styling for temperature readouts */
        .temp-popup .maplibregl-popup-content {
            background: rgba(18, 26, 43, 0.96);
            color: #e8edf5;
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 12px;
            padding: 10px 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }

        .temp-popup .maplibregl-popup-close-button {
            color: rgba(232, 237, 245, 0.85);
            font-size: 18px;
        }

        .temp-popup .maplibregl-popup-close-button:hover {
            background: rgba(255, 255, 255, 0.08);
            color: #e8edf5;
        }

        .temp-popup-title {
            font-size: 10px;
            color: #5a6478;
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .temp-popup-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 0.2px;
            color: #00d4ff;
            text-shadow: 0 1px 0 rgba(0, 0, 0, 0.35);
        }

        .overlay {
            position: fixed;
            z-index: 1000;
            background: rgba(18, 26, 43, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 16px;
            color: #e8edf5;
            /* NOTE: backdrop-filter can cause WebGL canvases (MapLibre) to render blank in some browsers. */
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .search-panel {
            top: calc(var(--ui-pad) + var(--safe-top));
            left: 50%;
            transform: translateX(-50%);
            width: min(420px, calc(100vw - (var(--ui-pad) * 2)));
            padding: 10px 12px;
        }

        .search-label {
            font-size: 10px;
            color: #5a6478;
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        #city-search {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.15);
            color: #e8edf5;
            font-size: 14px;
            outline: none;
        }

        #city-search::placeholder {
            color: rgba(232, 237, 245, 0.55);
        }

        #city-search:focus {
            border-color: rgba(0, 212, 255, 0.5);
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.15);
        }

        .search-results {
            display: none;
            margin-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            padding-top: 8px;
            max-height: 260px;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
        }

        .search-item {
            display: block;
            width: 100%;
            text-align: left;
            padding: 10px 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(0, 0, 0, 0.12);
            color: #e8edf5;
            cursor: pointer;
            margin-bottom: 8px;
        }

        .search-item:hover {
            background: rgba(0, 212, 255, 0.12);
            border-color: rgba(0, 212, 255, 0.25);
        }

        .search-item .meta {
            display: block;
            font-size: 11px;
            color: #8892a6;
            margin-top: 2px;
        }

        .logo {
            top: calc(var(--ui-pad) + var(--safe-top));
            left: calc(var(--ui-pad) + var(--safe-left));
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            font-size: 24px;
        }

        .logo-text {
            font-size: 18px;
            font-weight: 600;
        }

        .logo-text span {
            color: #8892a6;
            font-weight: 400;
        }

        .zoom-controls {
            top: calc(90px + var(--safe-top));
            left: calc(var(--ui-pad) + var(--safe-left));
            padding: 0;
        }

        .zoom-btn {
            display: block;
            width: 40px;
            height: 40px;
            background: transparent;
            border: none;
            color: #e8edf5;
            font-size: 20px;
            cursor: pointer;
        }

        .zoom-btn:first-child {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .zoom-btn:hover {
            background: #1a2540;
        }

        .month-display {
            top: calc(var(--ui-pad) + var(--safe-top));
            right: calc(var(--ui-pad) + var(--safe-right));
        }

        .month-label {
            font-size: 10px;
            color: #5a6478;
            text-transform: uppercase;
        }

        .month-value {
            font-size: 20px;
            font-weight: 500;
            color: #00d4ff;
            font-family: 'JetBrains Mono', monospace;
        }

        .stats-panel {
            top: calc(180px + var(--safe-top));
            left: calc(var(--ui-pad) + var(--safe-left));
            min-width: 160px;
        }

        .stats-title {
            font-size: 10px;
            color: #5a6478;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 12px;
            color: #8892a6;
        }

        .stat-value {
            font-size: 13px;
            font-family: 'JetBrains Mono', monospace;
        }

        .stat-value.hot {
            color: #ff6b6b;
        }

        .stat-value.cold {
            color: #00d4ff;
        }

        .stat-value.avg {
            color: #ffe566;
        }

        .bottom-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            padding: 20px 30px calc(25px + var(--safe-bottom));
            padding-left: calc(30px + var(--safe-left));
            padding-right: calc(30px + var(--safe-right));
            background: linear-gradient(to top, rgba(10, 14, 23, 0.98), rgba(10, 14, 23, 0.7) 70%, transparent);
        }

        .slider-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .month-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .month-labels span {
            font-size: 11px;
            color: #5a6478;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
        }

        .month-labels span:hover {
            background: #1a2540;
            color: #e8edf5;
        }

        .month-labels span.active {
            background: rgba(0, 212, 255, 0.15);
            color: #00d4ff;
        }

        .slider-track {
            position: relative;
            height: 6px;
            background: #1a2540;
            border-radius: 3px;
            margin-bottom: 15px;
        }

        .slider-progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ffcc);
            border-radius: 3px;
        }

        #month-slider {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            appearance: none;
            -webkit-appearance: none;
            background: transparent;
            cursor: pointer;
            margin: 0;
        }

        #month-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            margin-top: -5px;
        }

        .legend {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .legend-label {
            font-size: 10px;
            color: #5a6478;
            text-transform: uppercase;
        }

        .legend-bar {
            width: 200px;
            height: 8px;
            background: linear-gradient(90deg, #0044cc, #00ccff, #88ff44, #ffcc00, #ff4400);
            border-radius: 4px;
        }

        .heat-controls {
            margin-top: 14px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
        }

        .heat-row {
            width: 100%;
            max-width: 420px;
            display: flex;
            align-items: baseline;
            justify-content: space-between;
        }

        .heat-label {
            font-size: 10px;
            color: #5a6478;
            text-transform: uppercase;
        }

        .heat-value {
            font-size: 11px;
            color: #e8edf5;
            font-family: 'JetBrains Mono', monospace;
        }

        #heat-slider {
            width: 100%;
            max-width: 420px;
            appearance: none;
            -webkit-appearance: none;
            height: 6px;
            background: #1a2540;
            border-radius: 3px;
            outline: none;
        }

        #heat-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #fff;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        #heat-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border: none;
            background: #fff;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .loading-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(18, 26, 43, 0.95);
            padding: 20px 30px;
            border-radius: 12px;
            color: #e8edf5;
            z-index: 2000;
            display: none;
        }

        /* Mobile / small screens */
        @media (max-width: 600px) {
            :root {
                --ui-pad: 12px;
            }

            .search-panel {
                top: calc(70px + var(--safe-top));
                width: calc(100vw - (var(--ui-pad) * 2));
            }

            .overlay {
                padding: 10px 12px;
                border-radius: 10px;
            }

            .logo-text {
                font-size: 16px;
            }

            .logo-icon {
                font-size: 20px;
            }

            .zoom-controls {
                top: calc(70px + var(--safe-top));
            }

            .zoom-btn {
                width: 44px;
                height: 44px;
                font-size: 22px;
            }

            .month-value {
                font-size: 18px;
            }

            .stats-panel {
                top: calc(140px + var(--safe-top));
                left: calc(var(--ui-pad) + var(--safe-left));
                right: calc(var(--ui-pad) + var(--safe-right));
                min-width: 0;
            }

            .month-labels {
                justify-content: flex-start;
                gap: 8px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding-bottom: 4px;
            }

            .month-labels span {
                flex: 0 0 auto;
            }

            .bottom-panel {
                padding: 14px 14px calc(14px + var(--safe-bottom));
                padding-left: calc(14px + var(--safe-left));
                padding-right: calc(14px + var(--safe-right));
            }

            .legend {
                flex-wrap: wrap;
                gap: 10px;
            }

            .legend-bar {
                width: min(180px, 55vw);
            }

            #month-slider::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
                margin-top: -9px;
            }

            #month-slider::-moz-range-thumb {
                width: 24px;
                height: 24px;
                border: none;
                background: #fff;
                border-radius: 50%;
                cursor: grab;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            }

            #heat-slider::-webkit-slider-thumb {
                width: 22px;
                height: 22px;
            }

            #heat-slider::-moz-range-thumb {
                width: 22px;
                height: 22px;
            }
        }
    </style>
</head>

<body>
    <div id="map-container">
        <div id="map"></div>
        <canvas id="temp-canvas"></canvas>
    </div>

    <div class="overlay logo">
        <span class="logo-icon">ðŸŒ¡</span>
        <div class="logo-text">Temperature <span>Atlas</span></div>
    </div>

    <div class="overlay zoom-controls">
        <button class="zoom-btn" id="zoom-in">+</button>
        <button class="zoom-btn" id="zoom-out">âˆ’</button>
    </div>

    <div class="overlay month-display">
        <div class="month-label">Viewing</div>
        <div class="month-value" id="current-month">January</div>
    </div>

    <div class="overlay search-panel">
        <div class="search-label">Search city</div>
        <input id="city-search" type="search" placeholder="Type a city nameâ€¦" autocomplete="off" spellcheck="false">
        <div class="search-results" id="search-results"></div>
    </div>

    <div class="overlay stats-panel">
        <div class="stats-title">Statistics</div>
        <div class="stat-item"><span class="stat-label">Hottest</span><span class="stat-value hot"
                id="stat-hottest">--</span></div>
        <div class="stat-item"><span class="stat-label">Coldest</span><span class="stat-value cold"
                id="stat-coldest">--</span></div>
        <div class="stat-item"><span class="stat-label">Average</span><span class="stat-value avg"
                id="stat-average">--</span></div>
    </div>

    <div class="bottom-panel">
        <div class="slider-container">
            <div class="month-labels" id="month-labels"></div>
            <div class="slider-track">
                <div class="slider-progress" id="slider-progress"></div>
                <input type="range" id="month-slider" min="0" max="11" value="0">
            </div>
            <div class="legend">
                <span class="legend-label">-20Â°C</span>
                <div class="legend-bar"></div>
                <span class="legend-label">40Â°C</span>
            </div>

            <div class="heat-controls">
                <div class="heat-row">
                    <span class="heat-label">Overlay intensity</span>
                    <span class="heat-value" id="heat-value">35%</span>
                </div>
                <input type="range" id="heat-slider" min="0" max="200" value="35">
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loading">Rendering temperature field...</div>
    <div class="loading-overlay" id="error" style="display:none; max-width: 520px; white-space: pre-wrap;"></div>

    <script src="temperature_data.js"></script>
    <script>
        const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const MONTH_FULL = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        const MONTH_KEYS = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];

        const DEG2RAD = Math.PI / 180;

        let map, citiesData = [], currentMonth = 0;
        let canvas, ctx;
        let canvasCssWidth = 0, canvasCssHeight = 0, canvasDpr = 1;
        let renderTimeout = null;
        let isMapReady = false;
        let isDataReady = false;
        let isZooming = false;

        // Heat overlay state
        let heatIntensityPct = 35; // 0..200 (100 = normal, >100 boosts saturation/contrast)
        let heatOpacity = 0.35; // 0..1 (derived)
        let heatAnchorLngLat = null; // map center when the current heat image was rendered
        let heatAnchorPx = null;     // pixel position of heatAnchorLngLat at render time
        let heatAnchorZoom = null;   // map zoom when the current heat image was rendered
        let panRaf = null;
        let idleHeatRenderTimeout = null;
        const HEAT_IDLE_RENDER_MS = 260; // helps avoid re-render spam on tiny "bit by bit" drags
        const HEAT_RERENDER_THRESHOLD_PX = 56; // only re-render when the pan distance is noticeable

        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('error');
        const searchInputEl = document.getElementById('city-search');
        const searchResultsEl = document.getElementById('search-results');
        const heatSliderEl = document.getElementById('heat-slider');
        const heatValueEl = document.getElementById('heat-value');

        let tempPopup = null;
        let cityIndex = []; // [{ cityRef, q }]

        function showError(message) {
            console.error(message);
            if (errorEl) {
                errorEl.textContent = message;
                errorEl.style.display = 'block';
            } else {
                alert(message);
            }
        }

        function isWebGLAvailable() {
            try {
                const c = document.createElement('canvas');
                return !!(c.getContext('webgl') || c.getContext('experimental-webgl'));
            } catch {
                return false;
            }
        }

        function wrapDeltaLngDegrees(delta) {
            // Normalize to [-180, 180)
            delta = ((delta + 180) % 360 + 360) % 360 - 180;
            return delta;
        }

        function clamp01(x) {
            return Math.max(0, Math.min(1, x));
        }

        function setHeatOpacity(next) {
            heatOpacity = clamp01(next);
            if (canvas) {
                const moving = clamp01(Math.min(heatOpacity, 0.5) * 0.55);
                canvas.style.setProperty('--heat-opacity', String(heatOpacity));
                canvas.style.setProperty('--heat-opacity-moving', String(moving));
            }
            if (heatValueEl) heatValueEl.textContent = Math.round(heatOpacity * 100) + '%';

            // If turned fully off, clear the canvas to avoid a stale overlay.
            if (ctx && canvas && heatOpacity <= 0.001) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        function setHeatIntensityPct(nextPct) {
            const pct = Math.max(0, Math.min(200, Number(nextPct) || 0));
            heatIntensityPct = pct;

            // 0..100 -> opacity 0..1
            // 100..200 -> keep opacity at 1 and boost saturation/contrast
            const raw = pct / 100;
            const boost = Math.max(0, raw - 1); // 0..1

            const opacity = Math.min(1, raw);
            const saturate = 1 + boost * 1.5;  // 1.0 -> 2.5
            const contrast = 1 + boost * 0.75; // 1.0 -> 1.75

            if (canvas) {
                canvas.style.setProperty('--heat-saturate', String(saturate));
                canvas.style.setProperty('--heat-contrast', String(contrast));
            }

            setHeatOpacity(opacity);
            if (heatValueEl) heatValueEl.textContent = Math.round(pct) + '%';

            // Keep the control in sync if this was changed programmatically.
            if (heatSliderEl && String(heatSliderEl.value) !== String(Math.round(pct))) {
                heatSliderEl.value = String(Math.round(pct));
            }
        }

        function normalizeText(s) {
            return (s || '')
                .toString()
                .toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '');
        }

        function clearSearchResults() {
            if (!searchResultsEl) return;
            searchResultsEl.innerHTML = '';
            searchResultsEl.style.display = 'none';
        }

        function renderSearchResults(results) {
            if (!searchResultsEl) return;
            if (!results.length) {
                clearSearchResults();
                return;
            }
            searchResultsEl.style.display = 'block';
            searchResultsEl.innerHTML = '';
            for (const c of results) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'search-item';
                btn.innerHTML = `<strong>${c.city}</strong><span class="meta">${c.country}</span>`;
                btn.onclick = () => selectCity(c);
                searchResultsEl.appendChild(btn);
            }
        }

        function getMonthKey() {
            return MONTH_KEYS[currentMonth];
        }

        function showTempPopupAt(lngLat, opts = {}) {
            if (!map || !window.maplibregl) return;
            if (!citiesData.length) return;
            const monthKey = getMonthKey();
            const t = (opts && typeof opts.temp === 'number') ? opts.temp : interpolateTemp(lngLat.lat, lngLat.lng, citiesData, monthKey);
            const title = (opts && opts.title) ? opts.title : MONTH_FULL[currentMonth];
            const subtitle = (opts && opts.subtitle) ? opts.subtitle : '';

            const value = (t == null) ? 'â€”' : (t.toFixed(1) + 'Â°C');
            const html = `
                <div class="temp-popup-title">${title}${subtitle ? ' â€¢ ' + subtitle : ''}</div>
                <div class="temp-popup-value">${value}</div>
            `;

            if (!tempPopup) tempPopup = new maplibregl.Popup({ closeButton: true, closeOnClick: true, className: 'temp-popup' });
            tempPopup.setLngLat(lngLat).setHTML(html).addTo(map);
        }

        function selectCity(city) {
            if (!map) return;
            clearSearchResults();
            if (searchInputEl) {
                searchInputEl.value = `${city.city}, ${city.country}`;
                searchInputEl.blur();
            }

            const targetZoom = Math.max(map.getZoom ? map.getZoom() : 2, 4);
            map.flyTo({ center: [city.lng, city.lat], zoom: targetZoom, duration: 650 });

            const t = city[getMonthKey()];
            showTempPopupAt({ lng: city.lng, lat: city.lat }, {
                temp: (typeof t === 'number') ? t : null,
                title: `${city.city}, ${city.country}`,
                subtitle: MONTH_FULL[currentMonth]
            });
        }

        function updateHeatAnchor() {
            if (!map) return;
            if (!map.project || !map.getCenter) return;
            heatAnchorLngLat = map.getCenter();
            heatAnchorPx = map.project(heatAnchorLngLat);
            heatAnchorZoom = map.getZoom ? map.getZoom() : null;
            if (canvas) canvas.style.transform = 'translate3d(0px, 0px, 0) scale(1)';
        }

        function getHeatTransformPx() {
            if (!map || !map.project || !heatAnchorLngLat || !heatAnchorPx) return { dx: 0, dy: 0, dist: 0 };
            const p = map.project(heatAnchorLngLat);
            const dx = p.x - heatAnchorPx.x;
            const dy = p.y - heatAnchorPx.y;
            const dist = Math.hypot(dx, dy);
            return { dx, dy, dist };
        }

        function cancelScheduledRender() {
            if (renderTimeout) {
                clearTimeout(renderTimeout);
                renderTimeout = null;
            }
        }

        // Temperature to RGB color
        function tempToRGB(t) {
            t = Math.max(-20, Math.min(40, t));
            const stops = [
                [-20, 0, 68, 204],
                [-10, 0, 136, 255],
                [0, 0, 204, 255],
                [10, 0, 255, 204],
                [15, 68, 255, 136],
                [20, 136, 255, 68],
                [25, 204, 255, 0],
                [30, 255, 204, 0],
                [35, 255, 102, 0],
                [40, 204, 0, 34]
            ];
            for (let i = 0; i < stops.length - 1; i++) {
                if (t >= stops[i][0] && t <= stops[i + 1][0]) {
                    const ratio = (t - stops[i][0]) / (stops[i + 1][0] - stops[i][0]);
                    return [
                        Math.round(stops[i][1] + (stops[i + 1][1] - stops[i][1]) * ratio),
                        Math.round(stops[i][2] + (stops[i + 1][2] - stops[i][2]) * ratio),
                        Math.round(stops[i][3] + (stops[i + 1][3] - stops[i][3]) * ratio)
                    ];
                }
            }
            return [204, 0, 34];
        }

        // IDW interpolation for a single point
        function interpolateTemp(lat, lng, cities, monthKey) {
            let weightedSum = 0;
            let weightSum = 0;
            const power = 2;

            // Scale longitude degrees by cos(lat) so distances are closer to "real" on a sphere.
            const cosLat = Math.cos(lat * DEG2RAD);

            for (const city of cities) {
                const t = city[monthKey];
                if (t == null) continue;

                const dLat = city.lat - lat;
                const dLng = wrapDeltaLngDegrees(city.lng - lng) * cosLat;
                const dist2 = dLat * dLat + dLng * dLng;

                // If we're essentially on a city point, use it directly (avoids singular weights).
                if (dist2 < 0.25) return t; // ~0.5Â° threshold

                const weight = power === 2 ? (1 / dist2) : (1 / Math.pow(dist2, power / 2));
                weightedSum += t * weight;
                weightSum += weight;
            }

            return weightSum > 0 ? weightedSum / weightSum : null;
        }

        // Render temperature field to canvas
        function renderTemperatureField() {
            if (!citiesData.length || !map || !isMapReady) return;
            if (!canvas || !ctx) return;

            // If the overlay is off, keep it empty.
            if (heatOpacity <= 0.001) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }

            const cssWidth = canvasCssWidth || window.innerWidth;
            const cssHeight = canvasCssHeight || window.innerHeight;
            const deviceWidth = canvas.width;
            const deviceHeight = canvas.height;
            const monthKey = MONTH_KEYS[currentMonth];

            // Use lower resolution for performance, then scale up
            const scale = 4; // Render at 1/4 resolution
            const renderWidth = Math.ceil(cssWidth / scale);
            const renderHeight = Math.ceil(cssHeight / scale);

            const imageData = ctx.createImageData(renderWidth, renderHeight);
            const data = imageData.data;

            // Use all cities for interpolation so the field is always continuous (even over oceans).
            const visibleCities = citiesData;

            for (let y = 0; y < renderHeight; y++) {
                for (let x = 0; x < renderWidth; x++) {
                    // Convert pixel -> lat/lng using the map projection (Mercator correct, antimeridian safe).
                    const px = Math.min(cssWidth - 1, (x + 0.5) * scale);
                    const py = Math.min(cssHeight - 1, (y + 0.5) * scale);
                    const lngLat = map.unproject([px, py]);
                    const lng = lngLat.lng;
                    const lat = lngLat.lat;

                    const temp = interpolateTemp(lat, lng, visibleCities, monthKey);
                    const idx = (y * renderWidth + x) * 4;

                    if (temp !== null) {
                        const [r, g, b] = tempToRGB(temp);
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = 160; // Moderate alpha for visibility + map underneath
                    } else {
                        data[idx + 3] = 0; // Transparent
                    }
                }
            }

            // Create temporary canvas for scaling
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = renderWidth;
            tempCanvas.height = renderHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);

            // Scale up to full size with smoothing
            ctx.clearRect(0, 0, deviceWidth, deviceHeight);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(tempCanvas, 0, 0, deviceWidth, deviceHeight);
        }

        // Debounced render
        function scheduleRender(opts = {}) {
            const afterRender = opts && typeof opts.afterRender === 'function' ? opts.afterRender : null;
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(() => {
                if (!isMapReady || !isDataReady) return;

                if (loadingEl) loadingEl.style.display = 'block';

                // Allow the loading overlay to paint before heavy work.
                requestAnimationFrame(() => {
                    try {
                        renderTemperatureField();
                    } catch (err) {
                        console.error(err);
                    } finally {
                        if (loadingEl) loadingEl.style.display = 'none';
                        // After a successful render, the heat image is now aligned to the current map view.
                        updateHeatAnchor();
                        if (afterRender) {
                            try { afterRender(); } catch { }
                        }
                    }
                });
            }, 100);
        }

        // Initialize map
        if (!window.maplibregl) {
            showError('Map library failed to load (maplibregl is missing). Check your network / ad-blocker.');
        } else if (!isWebGLAvailable()) {
            showError('WebGL is disabled or unavailable. MapLibre requires WebGL to render the map.');
        } else {
            try {
                // Use a CORS-friendly default style (Raster) as it's the most robust.
                const CARTO_RASTER_STYLE = {
                    version: 8,
                    sources: {
                        'carto-raster': {
                            type: 'raster',
                            tiles: [
                                'https://a.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png',
                                'https://b.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png',
                                'https://c.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png',
                                'https://d.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png'
                            ],
                            tileSize: 256,
                            attribution: 'Â© OpenStreetMap contributors, Â© CARTO'
                        }
                    },
                    layers: [
                        { id: 'carto-raster', type: 'raster', source: 'carto-raster' }
                    ]
                };

                map = new maplibregl.Map({
                    container: 'map',
                    style: CARTO_RASTER_STYLE,
                    center: [0, 20],
                    zoom: 2,
                    dragRotate: false,
                    pitchWithRotate: false
                });
            } catch (err) {
                showError('Map init failed: ' + (err && err.message ? err.message : String(err)));
            }
        }

        // Setup canvas
        canvas = document.getElementById('temp-canvas');
        if (canvas) {
            ctx = canvas.getContext('2d');
        }

        // Heat intensity slider
        if (heatSliderEl) {
            // initialize UI from defaults
            heatSliderEl.max = '200';
            heatSliderEl.value = String(Math.round(heatIntensityPct));
            heatSliderEl.addEventListener('input', (e) => {
                const pct = parseInt(e.target.value, 10);
                setHeatIntensityPct(pct);
            });
        }
        setHeatIntensityPct(heatIntensityPct);

        function resizeCanvas() {
            if (!canvas || !ctx) return;
            // IMPORTANT: cap DPR to reduce memory pressure on mobile (prevents WebGL map from disappearing).
            const dpr = Math.min(window.devicePixelRatio || 1, 2);

            const rect = canvas.getBoundingClientRect();
            const cssWidth = Math.round(rect.width);
            const cssHeight = Math.round(rect.height);
            if (!cssWidth || !cssHeight) return;

            canvasCssWidth = cssWidth;
            canvasCssHeight = cssHeight;
            canvasDpr = dpr;

            canvas.width = Math.round(cssWidth * dpr);
            canvas.height = Math.round(cssHeight * dpr);

            // Reset any transforms (defensive) and re-render.
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            if (map) map.resize();
            scheduleRender();
        }

        window.addEventListener('resize', resizeCanvas);
        if (window.visualViewport) {
            // Helps on mobile browsers where the visual viewport changes as the URL bar collapses/expands.
            window.visualViewport.addEventListener('resize', resizeCanvas);
        }
        resizeCanvas();

        // Map events
        if (map) {
            function cancelIdleHeatRender() {
                if (idleHeatRenderTimeout) {
                    clearTimeout(idleHeatRenderTimeout);
                    idleHeatRenderTimeout = null;
                }
            }

            function scheduleIdleHeatRender(force = false) {
                cancelIdleHeatRender();
                if (!canvas || !ctx) return;
                if (!isMapReady || !isDataReady) return;

                idleHeatRenderTimeout = setTimeout(() => {
                    idleHeatRenderTimeout = null;
                    if (!map) return;
                    if (map.isMoving && map.isMoving()) {
                        scheduleIdleHeatRender(force);
                        return;
                    }

                    // Only do the heavy re-render if the map moved far enough, or if forced (zoom end).
                    const { dist } = getHeatTransformPx();
                    if (!force && dist < HEAT_RERENDER_THRESHOLD_PX) {
                        // Keep the shifted overlay; it stays visually aligned and avoids "bit-by-bit" render spam.
                        if (canvas) canvas.classList.remove('is-moving');
                        return;
                    }

                    scheduleRender({
                        afterRender: () => {
                            if (canvas) {
                                canvas.classList.remove('is-hidden');
                                canvas.classList.remove('is-moving');
                            }
                        }
                    });
                }, HEAT_IDLE_RENDER_MS);
            }

            map.on('zoomstart', () => {
                isZooming = true;
                cancelIdleHeatRender();
                cancelScheduledRender();
                if (canvas) {
                    canvas.classList.add('is-moving');
                    canvas.classList.remove('is-hidden');
                }
            });

            map.on('zoomend', () => {
                isZooming = false;
                // Re-render immediately after zoom. We keep the previous overlay visible (scaled) while rendering.
                if (canvas) canvas.classList.add('is-moving');
                scheduleRender({
                    afterRender: () => {
                        if (canvas) canvas.classList.remove('is-moving');
                    }
                });
            });

            map.on('movestart', () => {
                cancelIdleHeatRender();
                cancelScheduledRender();
                if (!canvas || isZooming) return;
                if (!heatAnchorLngLat || !heatAnchorPx) updateHeatAnchor();
                canvas.classList.add('is-moving');
                canvas.classList.remove('is-hidden');
            });

            map.on('move', () => {
                if (!canvas) return;
                if (!heatAnchorLngLat || !heatAnchorPx) return;
                if (panRaf) return;
                panRaf = requestAnimationFrame(() => {
                    panRaf = null;
                    if (!canvas) return;
                    const { dx, dy } = getHeatTransformPx();
                    const z = map && map.getZoom ? map.getZoom() : null;
                    const s = (heatAnchorZoom != null && z != null) ? Math.pow(2, z - heatAnchorZoom) : 1;
                    canvas.style.transform = `translate3d(${dx}px, ${dy}px, 0) scale(${s})`;
                });
            });

            map.on('moveend', () => {
                if (!canvas) return;
                if (isZooming) return;
                // If a zoom just scheduled a forced re-render, don't override it with a non-forced moveend handler.
                if (idleHeatRenderTimeout) return;
                // Keep overlay visible and aligned (via transform), then only re-render if needed after a short idle.
                scheduleIdleHeatRender(false);
            });

            map.on('load', () => {
                isMapReady = true;
                console.log('Map loaded');
                scheduleRender();
            });
            map.on('error', (e) => {
                console.warn('Map error:', e);
            });

            // Click -> temperature popup
            map.on('click', (e) => {
                showTempPopupAt(e.lngLat);
            });
        }

        // Zoom controls
        document.getElementById('zoom-in').onclick = () => map && map.zoomIn();
        document.getElementById('zoom-out').onclick = () => map && map.zoomOut();

        // Month labels
        const labelsContainer = document.getElementById('month-labels');
        MONTHS.forEach((m, i) => {
            const span = document.createElement('span');
            span.textContent = m;
            if (i === 0) span.classList.add('active');
            span.onclick = () => { document.getElementById('month-slider').value = i; setMonth(i); };
            labelsContainer.appendChild(span);
        });

        function setMonth(m) {
            currentMonth = m;
            document.getElementById('current-month').textContent = MONTH_FULL[m];
            document.getElementById('slider-progress').style.width = (m / 11 * 100) + '%';
            document.querySelectorAll('#month-labels span').forEach((s, i) => s.classList.toggle('active', i === m));
            updateStats();
            scheduleRender();
        }

        function updateStats() {
            if (!citiesData.length) return;
            const temps = citiesData.map(c => c[MONTH_KEYS[currentMonth]]).filter(t => t != null);
            if (!temps.length) return;
            document.getElementById('stat-hottest').textContent = Math.max(...temps).toFixed(1) + 'Â°C';
            document.getElementById('stat-coldest').textContent = Math.min(...temps).toFixed(1) + 'Â°C';
            document.getElementById('stat-average').textContent = (temps.reduce((a, b) => a + b, 0) / temps.length).toFixed(1) + 'Â°C';
        }

        document.getElementById('month-slider').oninput = e => setMonth(parseInt(e.target.value));

        function setCitiesData(data) {
            citiesData = (data && data.cities) ? data.cities : [];
            isDataReady = citiesData.length > 0;
            console.log('Loaded', citiesData.length, 'cities');
            updateStats();
            scheduleRender();

            // Build search index
            cityIndex = citiesData.map(c => ({
                cityRef: c,
                q: normalizeText(`${c.city} ${c.country}`)
            }));

            if (searchInputEl) {
                searchInputEl.disabled = !isDataReady;
            }
        }

        // City search behavior
        if (searchInputEl) {
            searchInputEl.disabled = true;
            searchInputEl.addEventListener('input', () => {
                if (!isDataReady || !cityIndex.length) return;
                const q = normalizeText(searchInputEl.value).trim();
                if (q.length < 2) {
                    clearSearchResults();
                    return;
                }
                const matches = [];
                for (const row of cityIndex) {
                    if (row.q.includes(q)) matches.push(row.cityRef);
                    if (matches.length >= 8) break;
                }
                renderSearchResults(matches);
            });

            searchInputEl.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    clearSearchResults();
                    searchInputEl.blur();
                }
                if (e.key === 'Enter') {
                    if (!isDataReady || !cityIndex.length) return;
                    const q = normalizeText(searchInputEl.value).trim();
                    if (q.length < 2) return;
                    const first = cityIndex.find(row => row.q.includes(q));
                    if (first) selectCity(first.cityRef);
                }
            });
        }

        // Click outside the search panel closes the results
        document.addEventListener('click', (e) => {
            if (!searchResultsEl || !searchInputEl) return;
            const panel = searchResultsEl.closest('.search-panel');
            if (!panel) return;
            if (!panel.contains(e.target)) clearSearchResults();
        }, { capture: true });

        // Load data (prefer JS global for file:// compatibility; fallback to fetch).
        if (window.TEMPERATURE_DATA && window.TEMPERATURE_DATA.cities) {
            setCitiesData(window.TEMPERATURE_DATA);
        } else {
            fetch('temperature_data.json')
                .then(r => r.json())
                .then(setCitiesData)
                .catch(err => {
                    const msg = (err && err.message) ? err.message : String(err);
                    console.error('Fetch failed:', msg);
                });
        }
    </script>
</body>

</html>